# Contributing Guide

## Договоренности

### Правила работы с git и github


#### Оформление commits и Pull Requests

Описание коммитов и PRs следует делать на русском языке.

В качестве заголовка коммита нужно использовать номер задачи + заголовок задачи. Самый простой способ получить правильно сформированный заголовок - нажать на данную кнопку:

![](https://s.csssr.ru/U07B23NE8/2020-01-27_15-31-52_wxlxb.jpg)

В теле коммита должно быть описание того, что было сделано в рамках данного коммита. Решение одной задачи может быть разбито на несколько коммитов, при этом каждый коммит должен содержать одно атомарное изменение (не должно быть коммитов с промежуточным/нерабочим состоянием).

Данный подход позволит быстро найти нужную информацию при помощи git blame, а так же найти связь конкретного изменения с конкретной задачей.

При оформлении Pull Request'a так же в качестве заголовка следует использовать номер задачи + заголовок задачи.

При внесении изменений в код PR'a промежуточные коммиты нужно сквошить при помощи интерактивного ребейза. Оставлять следует только те коммиты, в которых велась работа непосредственно над задачей (то есть коммиты, связанные с изменениями в бизнес-логике, необходимыми для выполнения задачи).

#### Сопровождение Pull Request'a

Автор PR'a должен сам следить за тем, чтобы PR не "подвисал" на этапе ревью. Если такое происходит, то необходимо попросить разработчиков посмотреть PR.

Если по вашему PR были оставлены change requests или вопросы, то необходимо внести соответствующие изменении или объяснять почему они не нужны. После этого следует так же написать тем разработчикам, которые оставляли вопросы/change requets, чтобы они снова посмотрели внесенные вами изменения. Кнопку повторного запроса ревью в github нажимать не нужно, так как из-за этого не сразу видно, что по PRs были замечания и от кого конкретно они были.

После получения 2 апрувов PR следует вмержить. Мержит тот, кто сделал последний апрув или автор PR'a, если, например, ревьюер не может вмержить PR сразу (еще не прошли тесты) или ревьюер забыл вмержить PR.

### Компоненты
Директория с компонентом должна называться так же, как и сам компонент. Директория как правило содержит файлы `index.tsx`, `index.css` и `index.stories.tsx`. Если компонент содержит дочерние компоненты, то их следует размещать в директории `components` в данной директории. Тесты должны находиться в поддиректории `__tests__`.

Название файла с тестами должно соответсвовать названию файла с тестируемым модулем плюс суфикс `.test.`:

```
index.tsx -> index.test.tsx
classname.ts -> classname.test.ts
```

Каждый публичный компонент должен быть описан в storybook.

Примерная структура компонента:

```
SomeComponent
    __tests__
      index.test.tsx
    components
    index.tsx
    index.css
    index.stories.tsx 
```


Кроме того мы используем function component, соответсвенно для его реализации нужно использовать `arrow function`, и тип `React.FunctionComponent<T>`:

```typescript
const SomeComp: React.FunctionComponent<SomeCompProps> = ({ prop1, prop2 }) => {

}
```

В большинстве случаев лучше декомпозировать пропсы прямо в аргументах функции. Если же декомпоизция слишком громоздкая, то можно вынести декомпоизцию в тело функции

### Разбивка компонента
Если вы собираетесь разбить компонент на более мелкие сущности, то нужно придерживаться следующих правил:
1. Он (компонент) должен лежать в папке с дочерними компонентами (не быть в том же файле)
2. У него должен быть отдельный бэм-класс


### Использование enums
Ипользовать enum следует для объявления публичных или общих "перечислимых" типов. Если ваш тип предполагает использование вне компонента, то следует его объявить через enum. Например:

```typescript
enum Statuses {
  Normal = 'normal',
  Danger = 'danger',
  Warning = 'warning',
}
```

Это позволит переиспользовать этот тип во внешних компонентах (если их будут реализовывать сторонние разработчики). Не обязательно явно указывать значения enum, как в случае выше, но это может быть удобным, если вам нужно конкретное значение enum (чтобы избежать дополнительного парсинга значений)

Если тип конкретного компонента должен принимать только одно значение из enum, то можно делать так:

```typescript
type ComponentProps = {
  status: Statuses.Normal
}
```

Или несколько значений:

```typescript
type ComponentProps = {
  status: Statuses.Normal | Statuses.Danger
}
```

Вместо enum для определения перечислимых типов можно использовать такой способ:

```typescript
export const statuses = ['normal', 'danger', 'warning'] as const;
type Status = typeof statuses[number];
```

Его следует использовать в случае, если тип уникален для компонента, или если этот тип не публичен

### Наименование boolean-методов и констант для сохранения значения

Наименование boolean-методов для проверки на существование чего-либо нужно начинать с приставки `is` (`isDays()`, `isZooming()`, `isWidget()`, `isSomthing()`). Если вы хотите сохранить возвращаемое значение в переменную, то нужно переменную называть так же, как название метода, а импортируемому методу добавить приставку `get`:

```
import { isDays as getIsDays } from 'utils/time'

const isDays = getIsDays(data)
```

### Type vs Interface

Стоит использовать `type` (не `interface`) для объявления props, да и для любых других типов. `interface` стоит использовать тогда, когда вы описываете общий тип, который где-то нужно имплементировать. В данном примером такого случая может являться интерфейс IWidget. Он описывает общий публичный API виджетов, поэтому и является интерфейсом. Интерфейсы хорошо подходят для написания абстрактного кода, который не работает с конкретными типами или экземлярами, а ожидает получить любую сущность, реализующего заданный интерфейс. Подробноее по type vs interface можно почитать [здесь](https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c)

### Default Props
Не стоит использовать defaultProps в function component, вместо этого нужно использовать значения по умолчанию при деструктуризации props:

```typescript
const SomeComp: React.FunctionComponent<SomeCompProps> = ({ someValue = 'defaultValue' }) => {

}
```

### Комментарии к типам
Для описания полей типа нужно оставлять многострочный комментарий. Это необходимо для верной генерации документации. Пример:

```typescript
type DateProps = {
  /** Текущий день строительства скважины */
  currentDay?: number;
  /** Плановое время строительства (сутки) */
  planDaysCount?: number;
};
```

### Обновление версии пакета
Обновлять версию пакета нужно строго через `npm version (major | minor | patch | ...)` и в `master` ветке

```sh
> npm version patch
> git push origin master --follow-tags
> npm publish
```

### Стилизация switch конструкций
Поскольку в eslint нет такого правила, то договорились, что в switch все конструкции case нужно обрамлять фигурными скобками:
```js
// Хорошо
switch (value) {
  case 'top': {
    // ...
    return ''
  }
}

// Плохо
switch (value) {
  case 'top':
    return ''
}
```

### Использование formatLabel и unit

При разработке нового компонента или доработке существующего, надо учитывать
как лучше добавлять форматирование подписей и значений, а как указывать общие
единицы измерения, для этого есть несколько правил:

* если надо указать общие единицы измерения отдельно от данных, например на
осях линейного графика, тогда лучше добавить `props` вида `unit`;
* если надо указать единицы измерения рядом с данными, как например в тултипе,
то лучше добавить `props` с функцией форматирования подписей или значений;
* `props` для указания единиц измерения или форматирования, всегда должны
передаваться через данные, а не через датасет, чтобы при описании датасета для
виджета была информация какие виды форматирования поддерживает конкретный
виджет (см. пример RadarChart).

### Pair Programming

Парное программирование может использоваться для решения любой относительно сложной задачи. Если вы чувствуете, что вам может потребоваться помощь в решении задачи и/или что лучше сразу решать задачу в паре, чтобы знания об устройстве той или иной части проекта были у нескольких членов команды, то можно использоваться методику парного программирования.

Основной смысл парного программирования заключается в том, что над решением одной задачи работают сразу два разработчика. При этом в один момент времени пишет код только один из разработчиков, второй при этом должен анализировать предложенные решения, продумывать API, помогать выявлять ошибки и т. д. Подробнее можно почитать [здесь](https://en.wikipedia.org/wiki/Pair_programming) и [здесь](https://habr.com/ru/post/151563/). В некоторых случаях при планировании сразу будет назначаться пара для решения той или иной задачи. Обычно это будет происходить в том случае, когда нужно будет опыт старшего коллеги передать более младшему.

#### Процесс работы в паре

При работе в паре важно работать "сессиями" не более 1-го часа, либо до коммита. То есть "ведущий" разработчик пишет код пока не будет реализована одна фича (пока не будет сделан один атомарный коммит), либо 1 час, после этого "штурман" занимает место "ведущего" разработчика и цикл повторяется. Штурману важно следить не только за кодом, но и за соблюдением временных ограничений. Очень важно избегать ситуаций, когда только один разработчик все время пишет код. 

Кроме того, штурман не должен просто диктовать что именно нужно сделать. Такая проблема может быть, если штурман намного опытнее "ведущего". В данном случае следует направлять, а не выдавать готовое решение, иначе теряется смысл парного программирования как инструмента распространения знаний.

В целом, в один день не стоит работать в паре более чем 4 часа. Парное программирование само по себе может быть более тяжелым, чем обычное программирование. Так же время от времени пары должны меняться. Желательно, чтобы пара менялась после 2-3 совместных сессий, либо после решения одной большой задачи.


### Задачи на исследование/анализ (research)

При необходимости определиться со способом реализации той или иной функциональности на проекте необходимо:
1. Проанализировать все возможные способы решения задачи (прим. https://jira.csssr.io/browse/TSUB-88).
2. Выявить плюсы и минусы каждого способа.
3. Подробно описать каждый способ со всеми плюсами и минусами в комментариях к задаче.
4. Получить согласие от команды на решение задачи наиболее подходящим способом.
5. Реализовать MVP (не тратя время на доведение решения до "идеала") необходимой функциональности. Если в ходе реализации MVP не было выявлено существенных недостатков, то завести задачу на полноценную реализацию необходимой функциональности. Если же были выявлены существенные недостатки, то нужно либо продумать альтернативные способы решения задачи, либо выбрать из оставшихся способов (см. пункт 4).
6. Выполнить задачу (желательно отталкиваться от наработок из MVP).
